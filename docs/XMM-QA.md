# XMM技术设计Q&A


## 问题：XMM和Go内置gc性能对比如何？

回答了 https://github.com/heiyeluren/xmm/issues/21


### 问题：
请给我一个我会引入这个库的一个具体理由。
- 是否有对比实验证明这个库在某种tradeoff的情况下比golang自带的好？好多少？我自己是否可以在我的机器上运行这类对比实验？
- 看描述似乎这个库本身也带一个gc功能。那么在与官方golang的gc做的事情一样的情况下如何还能比官方golang的gc还好，就值得怀疑。
- 另外 单机（6 核心 KVM 或物理机）内存分配性能达到 350w+ alloc/s；（每秒内存分配速度）； 好像官方的golang的分配速度也是这个水平上（没有具体的机器谈具体的性能算扯淡哈），那边必然是在其他方面有优化，比如没有 gc 对吞吐量的延时影响？具体优化了啥？文档上没讲。

<br />



### 回答：
感谢 @bronze1man 提问，问题提的都非常好，一一给您解答。

1. 内存管理均衡性问题：

    从设计机制上面来说，XMM和go内置的gc机制没有太本质区别，都是从用户态通过系统调用mmap的方式从内核申请一大块内存进行管理，go内置内存管理和XMM在这个设计上是基本一样的，go的内存管理和XMM底层都是从tcmalloc中学习的设计思想，所以在常态使用中（不会gc，元素很少）中使用go内置内存管理和XMM都是没有太大区别，只是XMM个人可控性更强一些。


2. 关于XMM的gc和Go内置gc的对比：

    a.  关于gc的问题，本质就是最终内存回收的策略不同，决定性能不同。

    b.  go的内存回收是主动式和被动式两种的，主动式不说是用户触发，被动式主要两种，一种是内存分配时候达到了控制计算的大小，还有一种是达到了预期时间（比如2分钟），这两种自动场景都会进行gc，它会做包括 STW->三色标记(mark)->回收(Sweep) 等主要步骤，这个过程是用户态程序不可控的。

    c.  XMM的gc策略相对要高效很多，因为使用者需要调用Free()显示调用针对对象的标记(mark)，XMM触发回收(Sweep) 动作只有一个，那就是内存容量达到了现有总容量的阈值(默认是75%) 才会进行Sweep，并且在Sweep的时候，因为XMM的所有空闲内存节点元素都是保存在span中的bitmap中的，扫描和释放速度非常快，很快就结束了。

    d.  XMM跟go内置内存管理的没事就需要STW，扫描节点标记黑白灰然后Sweep的操作完全不同，虽然有混合写屏障等等，实际使用中还是会存在偶尔卡顿的情况。特别在元素非常多的情况下，比如说千万级元素，你想想每隔2分钟就会扫描一次，对于应用程序影响有多大，并且元素众多，需要进行黑白灰归类扫描，然后释放回收，绝对是性能会受到影响的。XMM不存在这个问题，标志是用户手动显示触发，但是回收过程都是内存达到容量使用的阈值，基本可以理解如果你申请内存足够大，有可能一直也遇不到GC的场景，如果遇到了，也只是简单访问一个bitmap(类数组)快速就结束了sweep工作。

    e. 从整个设计理念来看，Go的Gc本质是那种自助餐“勤拿少取，没事就收盘”的策略，会要求程序和Gc协程都是需要没事就进行扫描和回收工作的，但是XMM是自助餐“一把拿好，吃饱喝足”的策略，设计理念不同，决定了性能不同，当然使用场景也不同。在千万级别的item元素场景下，go的gc绝对是卡顿的，对于XMM来说是很轻松应付的。


3. 关于单机alloc分配性能的问题：

    a.  因为大家在底层设计思路都是借鉴与tcmalloc的设计思想 heap+span 等等，大块内存申请策略也都是从内核通过mmap一块内存块出来，所以在alloc的性能在300多万每秒本质上是不会太大区别的；

    b.  但是go内置内存管理在你alloc一个内存的时候，是很可能诱发gc的，那么这个时候会增加卡顿时间；而XMM除了达到了设定的内存使用阈值（目前是75%，可配置）才会gc，其它时间你都是可以轻松的alloc内存，如果申请元素非常少，大家性能是差不多的，那么在大部分场景下，或者元素稍微躲起来，肯定还是要XMM的alloc性能更高的。


4. 结论：
    所以综上所述，在需要超高性能，需要完成更多对象，需要自主内存可控制可管理场景，我觉得XMM是更好的选择！


回答内容有点多，希望对您有帮助，感谢~



参考链接：

https://blog.csdn.net/stayfoolish_yj/article/details/104692374

https://www.jianshu.com/p/96a52a8127d9


<br />

--------------------------------------------------------------------------------

<br />



## 问题：XMM有哪些适用场景呢？


适用场景问题：

https://github.com/heiyeluren/xmm/issues/18


### 问题：

- 如果项目中GC频率较低，或者说运行时golang的GC对项目不会产生任何抖动，是否也没太大必要使用XMM这个项目来手动管理内存？
- 这个项目是否主要适用于小对象过多造成的频繁GC导致cpu抖动这种场景，这种场景下手动管理就可以避免这种情况了？
- 比如说，像一个长期使用的sync.Pool，是否使用XMM管理就比较合适？

<br />



### 回答：

1. 如果完全没有gc问题可以不考虑，常规就是CURD的程序，无所谓是否gc的问题。

2. 这个项目适用对象多，另外有一些需要自己独立管理内存的场景：

a. 其实很多人有需要自己独立控制内存，比如有一个内存我想常驻，不想被没事gc就扫描一下，就可以使用xmm；

b. 我举个例子，比如我一个配置文件，会热更新，并且经常会被程序访问这个配置文件中的内容，那我就可以放xmm里，gc不会管它。

c. 临时变量这种，用完就扔的没必要用xmm

d. 延展一点说：如果你有一些想要本地Cache的东西，建议采用XMM，不会频繁被gc扫描；比如有些数据要热加载，然后长期会存在，程序自己会更新，那就用XMM非常合适。

对的，就是处理类似于使用 sync.Pool 或者自己用一个[]byte存储数据不被gc的场景


<br />



--------------------------------------------------------------------------------

<br />



## 问题：为什么选择用XMM而不是适用 C++或Rust？

用c++/rust问题：
我觉得超高性能场景就用rust或者c/c++ 吧 · Issue #7 · heiyeluren/xmm (github.com)


### 问题：
- 我觉得炒高性能场景就用rust或者c/c++吧；

<br />


### 回答：
XMM主要场景是想要自主管理内存的场景，在Go中想要自主管理内存不经过GC是没办法的~ 只能字节流等等比较粗糙的方式，针对这种场景所以才开发了XMM。
XMM主要就是应对哪些从C++转到Go的想要自主管理内存，还有用Go无法管理内存想转到Rust的这些用户；

目前版本就是手动Free内存，不是不加上GC功能，是加了GC，就是跟go内置GC一样了，绕了一圈又回去了，所以才选择这种方式；

另外，本质来说，XMM是为了解决那些想自己管理内存，提升程序性能，并不被GC影响性能的开发者和应用场景；如果一个CURD场景的，完全没必要使用XMM，内置的map/slice等基本就够用了。
XMM就是为了底层解决高性能以及自主内存可控制不会被GC影响等场景的问题存在的，就是为了弥补Go内置没有能够自己管理内存操作存在的。Go gc是一个大黑盒，几乎不暴露任何接口，对很多追求极致性能或者是想内存可控的程序员来说是非常痛苦的，只有自己遇到才会懂，所以才开发了XMM。

并且使用go内置的cgo接口性能是一个问题，另外 没人会写rust/c/c++的时候，先学后写太费时间了。


<br />


--------------------------------------------------------------------------------

<br />



## 问题：关于XMM的tradeoff问题

关于tradeoff的问题：
What's the tradeoff? · Issue #10 · heiyeluren/xmm (github.com)

<br />


### 问题：

项目看起来很酷，但是在阅读完README之后并没有看到关于「取舍」、「适用场景」及 「不适用场景」 的描述。

一些比较好奇的点：
- 请问有不同情景下（对象大小、堆使用量etc）的benchmark吗？
- XMM的GC性能与go自带GC的比较？GC的频率以及单次GC耗时？
- “在面对成千上万的小对象场景中，不会因为 Go 本身 GC 机制带来任何的抖动” -- XMM的GC带来的抖动呢？如果是手工free的话，手工free部分的开销是多少？
- “不会内存泄露，并且内存管理不是粗糙的，而颗粒度细致的，完全尽量可媲美行业主流的内存管理分配器。” -- 有数据支撑吗？
- 大对象/小对象/大小混合对象下的内存占用overhead是多少？对比go？

总结起来是：单从性能的角度，忽略额外的编码复杂度来讲：何时使用XMM而不使用go自带内存管理？更重要的是，何时使用go自带的内存管理而不使用XMM？

<br />



### 回答：

XMM主要场景是想要自主管理内存的场景，在Go中想要自主管理内存不经过GC是没办法的~ 只能字节流等等比较粗糙的方式，针对这种场景所以才开发了XMM。
XMM主要就是应对哪些从C++转到Go的想要自主管理内存，还有用Go无法管理内存想转到Rust的这些用户；
目前版本就是手动Free内存，不是不加上GC功能，是加了GC，就是跟go内置GC一样了，绕了一圈又回去了，所以才选择这种方式；
但是看未来发展方向，也可能会增加自动GC功能，大概率也是引用计数或三色标记这些算法；


另外，本质来说，XMM是为了解决那些想自己管理内存，提升程序性能，并不被GC影响性能的开发者和应用场景；如果一个CURD场景的，完全没必要使用XMM，内置的map/slice等基本就够用了。
XMM就是为了底层解决高性能以及自主内存可控制不会被GC影响等场景的问题存在的，就是为了弥补Go内置没有能够自己管理内存操作存在的。Go gc是一个大黑盒，几乎不暴露任何接口，对很多追求极致性能或者是想内存可控的程序员来说是非常痛苦的，只有自己遇到才会懂，所以才开发了XMM。


<br />


